import fs from 'node:fs/promises'
import path from 'node:path'

const payloadURL = process.env.PUBLIC_PAYLOAD_URL ?? process.env.PAYLOAD_URL
const isCI = process.env.CI === 'true'
const strictSync = process.env.SUPPORT_SYNC_STRICT === 'true'

if (!payloadURL) {
  console.error('Missing PUBLIC_PAYLOAD_URL (or PAYLOAD_URL).')
  process.exit(1)
}

const docsRoot = path.resolve(process.cwd(), 'src/content/docs')
const managedRoot = path.join(docsRoot, 'support')
const generatedRoot = path.resolve(process.cwd(), 'src/generated')
const generatedSidebarPath = path.join(generatedRoot, 'support-sidebar.mjs')
const emptySidebarModule = '// Auto-generated by scripts/sync-support-docs.mjs\nexport default []\n'

async function writeEmptyArtifacts() {
  await fs.rm(managedRoot, { recursive: true, force: true })
  await fs.mkdir(managedRoot, { recursive: true })
  await fs.mkdir(generatedRoot, { recursive: true })
  await fs.writeFile(generatedSidebarPath, emptySidebarModule, 'utf8')
}

function validatePayloadURL() {
  let parsed
  try {
    parsed = new URL(payloadURL)
  } catch {
    throw new Error(
      `PUBLIC_PAYLOAD_URL is invalid: "${payloadURL}". Expected full URL like https://astro-payload-cms.netlify.app`,
    )
  }
  if (!['http:', 'https:'].includes(parsed.protocol)) {
    throw new Error(`PUBLIC_PAYLOAD_URL must start with http:// or https://. Received: ${payloadURL}`)
  }
}

function toMarkdownFrontmatter({ title, description, pageOrder }) {
  const safeTitle = String(title ?? '').replaceAll('"', '\\"')
  const safeDescription = String(description ?? '').replaceAll('"', '\\"')
  const safeOrder = Number.isFinite(Number(pageOrder)) ? Number(pageOrder) : 0
  return `---\ntitle: "${safeTitle}"\ndescription: "${safeDescription}"\nsidebar:\n  order: ${safeOrder}\n---\n\n`
}

function normalizeMarkdownBody(body) {
  const value = String(body ?? '')
  if (!value.endsWith('\n')) return `${value}\n`
  return value
}

async function fetchCollection(url) {
  const controller = new AbortController()
  const timeout = setTimeout(() => controller.abort(), 10000)
  let res
  try {
    res = await fetch(url, { signal: controller.signal })
  } catch (error) {
    clearTimeout(timeout)
    if (error?.name === 'AbortError') {
      throw new Error(`Timed out fetching ${url}`)
    }
    throw new Error(
      `Could not reach Payload at ${payloadURL}. Check PUBLIC_PAYLOAD_URL and make sure Payload dev server is running.`,
    )
  }
  clearTimeout(timeout)
  if (!res.ok) {
    throw new Error(`Payload request failed (${res.status}) for ${url}`)
  }
  return res.json()
}

async function main() {
  validatePayloadURL()

  const categoriesURL = new URL('/api/support-categories', payloadURL)
  categoriesURL.searchParams.set('limit', '1000')
  categoriesURL.searchParams.set('sort', 'order')

  const pagesURL = new URL('/api/support-pages', payloadURL)
  pagesURL.searchParams.set('limit', '1000')
  pagesURL.searchParams.set('depth', '1')
  pagesURL.searchParams.set('sort', 'order')
  pagesURL.searchParams.set('where[_status][equals]', 'published')

  const [categoryData, pageData] = await Promise.all([
    fetchCollection(categoriesURL.toString()),
    fetchCollection(pagesURL.toString()),
  ])

  const categories = categoryData.docs ?? []
  const pages = pageData.docs ?? []

  const categoryById = new Map(categories.map((category) => [String(category.id), category]))
  const categoryOrderById = new Map(
    categories.map((category, index) => [String(category.id), Number.isFinite(Number(category.order)) ? Number(category.order) : index]),
  )
  const sortedPages = [...pages].sort((a, b) => {
    const aCategoryId = String(typeof a.category === 'object' ? a.category?.id : a.category)
    const bCategoryId = String(typeof b.category === 'object' ? b.category?.id : b.category)
    const aCategoryOrder = categoryOrderById.get(aCategoryId) ?? Number.MAX_SAFE_INTEGER
    const bCategoryOrder = categoryOrderById.get(bCategoryId) ?? Number.MAX_SAFE_INTEGER
    if (aCategoryOrder !== bCategoryOrder) return aCategoryOrder - bCategoryOrder

    const aOrder = Number.isFinite(Number(a.order)) ? Number(a.order) : 0
    const bOrder = Number.isFinite(Number(b.order)) ? Number(b.order) : 0
    if (aOrder !== bOrder) return aOrder - bOrder

    return String(a.title ?? '').localeCompare(String(b.title ?? ''))
  })

  await fs.rm(managedRoot, { recursive: true, force: true })
  await fs.mkdir(managedRoot, { recursive: true })
  await fs.mkdir(generatedRoot, { recursive: true })

  for (const page of sortedPages) {
    const categoryRef = typeof page.category === 'object' ? page.category : categoryById.get(String(page.category))
    if (!categoryRef?.slug) {
      console.warn(`Skipping page "${page.title}" because category is missing a slug.`)
      continue
    }

    const categoryDir = path.join(managedRoot, String(categoryRef.slug))
    await fs.mkdir(categoryDir, { recursive: true })

    const pageSlug = String(page.slug ?? '').trim()
    if (!pageSlug) {
      console.warn(`Skipping page "${page.title}" because slug is empty.`)
      continue
    }

    const filePath = path.join(categoryDir, `${pageSlug}.md`)
    const description = page.excerpt || `Support article in ${categoryRef.title}`
    const content =
      toMarkdownFrontmatter({
        title: page.title,
        description,
        pageOrder: page.order,
      }) + normalizeMarkdownBody(page.body)

    await fs.writeFile(filePath, content, 'utf8')
  }

  const sidebar = categories.map((category) => ({
    label: String(category.title),
    autogenerate: { directory: `support/${String(category.slug)}` },
  }))

  const sidebarModule = `// Auto-generated by scripts/sync-support-docs.mjs\nexport default ${JSON.stringify(
    sidebar,
    null,
    2,
  )}\n`

  await fs.writeFile(generatedSidebarPath, sidebarModule, 'utf8')

  console.log(`Synced ${sortedPages.length} support page(s) into ${managedRoot}`)
  console.log(`Generated sidebar config at ${generatedSidebarPath}`)
}

main().catch((error) => {
  const message = error instanceof Error ? error.message : String(error)
  if (isCI && !strictSync) {
    console.warn(`[sync:support] ${message}`)
    console.warn('[sync:support] Continuing CI build with empty support docs. Set SUPPORT_SYNC_STRICT=true to fail instead.')
    writeEmptyArtifacts()
      .then(() => process.exit(0))
      .catch((writeErr) => {
        console.error(writeErr instanceof Error ? writeErr.message : String(writeErr))
        process.exit(1)
      })
    return
  }
  console.error(message)
  process.exit(1)
})
